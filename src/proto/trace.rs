// This file is generated by rust-protobuf 2.8.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/devtools/cloudtrace/v2/trace.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_2;

#[derive(PartialEq,Clone,Default)]
pub struct Span {
    // message fields
    pub name: ::std::string::String,
    pub span_id: ::std::string::String,
    pub parent_span_id: ::std::string::String,
    pub display_name: ::protobuf::SingularPtrField<TruncatableString>,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub attributes: ::protobuf::SingularPtrField<Span_Attributes>,
    pub stack_trace: ::protobuf::SingularPtrField<StackTrace>,
    pub time_events: ::protobuf::SingularPtrField<Span_TimeEvents>,
    pub links: ::protobuf::SingularPtrField<Span_Links>,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub same_process_as_parent_span: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub child_span_count: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span {
    fn default() -> &'a Span {
        <Span as ::protobuf::Message>::default_instance()
    }
}

impl Span {
    pub fn new() -> Span {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string span_id = 2;


    pub fn get_span_id(&self) -> &str {
        &self.span_id
    }
    pub fn clear_span_id(&mut self) {
        self.span_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_span_id(&mut self, v: ::std::string::String) {
        self.span_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_span_id(&mut self) -> &mut ::std::string::String {
        &mut self.span_id
    }

    // Take field
    pub fn take_span_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.span_id, ::std::string::String::new())
    }

    // string parent_span_id = 3;


    pub fn get_parent_span_id(&self) -> &str {
        &self.parent_span_id
    }
    pub fn clear_parent_span_id(&mut self) {
        self.parent_span_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_span_id(&mut self, v: ::std::string::String) {
        self.parent_span_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_span_id(&mut self) -> &mut ::std::string::String {
        &mut self.parent_span_id
    }

    // Take field
    pub fn take_parent_span_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent_span_id, ::std::string::String::new())
    }

    // .google.devtools.cloudtrace.v2.TruncatableString display_name = 4;


    pub fn get_display_name(&self) -> &TruncatableString {
        self.display_name.as_ref().unwrap_or_else(|| TruncatableString::default_instance())
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: TruncatableString) {
        self.display_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut TruncatableString {
        if self.display_name.is_none() {
            self.display_name.set_default();
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> TruncatableString {
        self.display_name.take().unwrap_or_else(|| TruncatableString::new())
    }

    // .google.protobuf.Timestamp start_time = 5;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end_time = 6;


    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.devtools.cloudtrace.v2.Span.Attributes attributes = 7;


    pub fn get_attributes(&self) -> &Span_Attributes {
        self.attributes.as_ref().unwrap_or_else(|| Span_Attributes::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: Span_Attributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut Span_Attributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> Span_Attributes {
        self.attributes.take().unwrap_or_else(|| Span_Attributes::new())
    }

    // .google.devtools.cloudtrace.v2.StackTrace stack_trace = 8;


    pub fn get_stack_trace(&self) -> &StackTrace {
        self.stack_trace.as_ref().unwrap_or_else(|| StackTrace::default_instance())
    }
    pub fn clear_stack_trace(&mut self) {
        self.stack_trace.clear();
    }

    pub fn has_stack_trace(&self) -> bool {
        self.stack_trace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_trace(&mut self, v: StackTrace) {
        self.stack_trace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stack_trace(&mut self) -> &mut StackTrace {
        if self.stack_trace.is_none() {
            self.stack_trace.set_default();
        }
        self.stack_trace.as_mut().unwrap()
    }

    // Take field
    pub fn take_stack_trace(&mut self) -> StackTrace {
        self.stack_trace.take().unwrap_or_else(|| StackTrace::new())
    }

    // .google.devtools.cloudtrace.v2.Span.TimeEvents time_events = 9;


    pub fn get_time_events(&self) -> &Span_TimeEvents {
        self.time_events.as_ref().unwrap_or_else(|| Span_TimeEvents::default_instance())
    }
    pub fn clear_time_events(&mut self) {
        self.time_events.clear();
    }

    pub fn has_time_events(&self) -> bool {
        self.time_events.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_events(&mut self, v: Span_TimeEvents) {
        self.time_events = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_events(&mut self) -> &mut Span_TimeEvents {
        if self.time_events.is_none() {
            self.time_events.set_default();
        }
        self.time_events.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_events(&mut self) -> Span_TimeEvents {
        self.time_events.take().unwrap_or_else(|| Span_TimeEvents::new())
    }

    // .google.devtools.cloudtrace.v2.Span.Links links = 10;


    pub fn get_links(&self) -> &Span_Links {
        self.links.as_ref().unwrap_or_else(|| Span_Links::default_instance())
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    pub fn has_links(&self) -> bool {
        self.links.is_some()
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: Span_Links) {
        self.links = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_links(&mut self) -> &mut Span_Links {
        if self.links.is_none() {
            self.links.set_default();
        }
        self.links.as_mut().unwrap()
    }

    // Take field
    pub fn take_links(&mut self) -> Span_Links {
        self.links.take().unwrap_or_else(|| Span_Links::new())
    }

    // .google.rpc.Status status = 11;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| super::status::Status::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .google.protobuf.BoolValue same_process_as_parent_span = 12;


    pub fn get_same_process_as_parent_span(&self) -> &::protobuf::well_known_types::BoolValue {
        self.same_process_as_parent_span.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::default_instance())
    }
    pub fn clear_same_process_as_parent_span(&mut self) {
        self.same_process_as_parent_span.clear();
    }

    pub fn has_same_process_as_parent_span(&self) -> bool {
        self.same_process_as_parent_span.is_some()
    }

    // Param is passed by value, moved
    pub fn set_same_process_as_parent_span(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.same_process_as_parent_span = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_same_process_as_parent_span(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.same_process_as_parent_span.is_none() {
            self.same_process_as_parent_span.set_default();
        }
        self.same_process_as_parent_span.as_mut().unwrap()
    }

    // Take field
    pub fn take_same_process_as_parent_span(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.same_process_as_parent_span.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.protobuf.Int32Value child_span_count = 13;


    pub fn get_child_span_count(&self) -> &::protobuf::well_known_types::Int32Value {
        self.child_span_count.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }
    pub fn clear_child_span_count(&mut self) {
        self.child_span_count.clear();
    }

    pub fn has_child_span_count(&self) -> bool {
        self.child_span_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_span_count(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.child_span_count = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_child_span_count(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.child_span_count.is_none() {
            self.child_span_count.set_default();
        }
        self.child_span_count.as_mut().unwrap()
    }

    // Take field
    pub fn take_child_span_count(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.child_span_count.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }
}

impl ::protobuf::Message for Span {
    fn is_initialized(&self) -> bool {
        for v in &self.display_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stack_trace {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_events {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.same_process_as_parent_span {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child_span_count {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.span_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent_span_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.display_name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stack_trace)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_events)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.links)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.same_process_as_parent_span)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.child_span_count)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.span_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.span_id);
        }
        if !self.parent_span_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.parent_span_id);
        }
        if let Some(ref v) = self.display_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stack_trace.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.time_events.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.links.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.same_process_as_parent_span.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.child_span_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.span_id.is_empty() {
            os.write_string(2, &self.span_id)?;
        }
        if !self.parent_span_id.is_empty() {
            os.write_string(3, &self.parent_span_id)?;
        }
        if let Some(ref v) = self.display_name.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stack_trace.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.time_events.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.links.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.same_process_as_parent_span.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.child_span_count.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span {
        Span::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Span| { &m.name },
                    |m: &mut Span| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "span_id",
                    |m: &Span| { &m.span_id },
                    |m: &mut Span| { &mut m.span_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent_span_id",
                    |m: &Span| { &m.parent_span_id },
                    |m: &mut Span| { &mut m.parent_span_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                    "display_name",
                    |m: &Span| { &m.display_name },
                    |m: &mut Span| { &mut m.display_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "start_time",
                    |m: &Span| { &m.start_time },
                    |m: &mut Span| { &mut m.start_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "end_time",
                    |m: &Span| { &m.end_time },
                    |m: &mut Span| { &mut m.end_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Attributes>>(
                    "attributes",
                    |m: &Span| { &m.attributes },
                    |m: &mut Span| { &mut m.attributes },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StackTrace>>(
                    "stack_trace",
                    |m: &Span| { &m.stack_trace },
                    |m: &mut Span| { &mut m.stack_trace },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_TimeEvents>>(
                    "time_events",
                    |m: &Span| { &m.time_events },
                    |m: &mut Span| { &mut m.time_events },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Links>>(
                    "links",
                    |m: &Span| { &m.links },
                    |m: &mut Span| { &mut m.links },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                    "status",
                    |m: &Span| { &m.status },
                    |m: &mut Span| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                    "same_process_as_parent_span",
                    |m: &Span| { &m.same_process_as_parent_span },
                    |m: &mut Span| { &mut m.same_process_as_parent_span },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "child_span_count",
                    |m: &Span| { &m.child_span_count },
                    |m: &mut Span| { &mut m.child_span_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Span>(
                    "Span",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Span {
        static mut instance: ::protobuf::lazy::Lazy<Span> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Span,
        };
        unsafe {
            instance.get(Span::new)
        }
    }
}

impl ::protobuf::Clear for Span {
    fn clear(&mut self) {
        self.name.clear();
        self.span_id.clear();
        self.parent_span_id.clear();
        self.display_name.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.attributes.clear();
        self.stack_trace.clear();
        self.time_events.clear();
        self.links.clear();
        self.status.clear();
        self.same_process_as_parent_span.clear();
        self.child_span_count.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_Attributes {
    // message fields
    pub attribute_map: ::std::collections::HashMap<::std::string::String, AttributeValue>,
    pub dropped_attributes_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_Attributes {
    fn default() -> &'a Span_Attributes {
        <Span_Attributes as ::protobuf::Message>::default_instance()
    }
}

impl Span_Attributes {
    pub fn new() -> Span_Attributes {
        ::std::default::Default::default()
    }

    // repeated .google.devtools.cloudtrace.v2.Span.Attributes.AttributeMapEntry attribute_map = 1;


    pub fn get_attribute_map(&self) -> &::std::collections::HashMap<::std::string::String, AttributeValue> {
        &self.attribute_map
    }
    pub fn clear_attribute_map(&mut self) {
        self.attribute_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute_map(&mut self, v: ::std::collections::HashMap<::std::string::String, AttributeValue>) {
        self.attribute_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_map(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, AttributeValue> {
        &mut self.attribute_map
    }

    // Take field
    pub fn take_attribute_map(&mut self) -> ::std::collections::HashMap<::std::string::String, AttributeValue> {
        ::std::mem::replace(&mut self.attribute_map, ::std::collections::HashMap::new())
    }

    // int32 dropped_attributes_count = 2;


    pub fn get_dropped_attributes_count(&self) -> i32 {
        self.dropped_attributes_count
    }
    pub fn clear_dropped_attributes_count(&mut self) {
        self.dropped_attributes_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_attributes_count(&mut self, v: i32) {
        self.dropped_attributes_count = v;
    }
}

impl ::protobuf::Message for Span_Attributes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<AttributeValue>>(wire_type, is, &mut self.attribute_map)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dropped_attributes_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<AttributeValue>>(1, &self.attribute_map);
        if self.dropped_attributes_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.dropped_attributes_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<AttributeValue>>(1, &self.attribute_map, os)?;
        if self.dropped_attributes_count != 0 {
            os.write_int32(2, self.dropped_attributes_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_Attributes {
        Span_Attributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<AttributeValue>>(
                    "attribute_map",
                    |m: &Span_Attributes| { &m.attribute_map },
                    |m: &mut Span_Attributes| { &mut m.attribute_map },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dropped_attributes_count",
                    |m: &Span_Attributes| { &m.dropped_attributes_count },
                    |m: &mut Span_Attributes| { &mut m.dropped_attributes_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Span_Attributes>(
                    "Span_Attributes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Span_Attributes {
        static mut instance: ::protobuf::lazy::Lazy<Span_Attributes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Span_Attributes,
        };
        unsafe {
            instance.get(Span_Attributes::new)
        }
    }
}

impl ::protobuf::Clear for Span_Attributes {
    fn clear(&mut self) {
        self.attribute_map.clear();
        self.dropped_attributes_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_Attributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_Attributes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_TimeEvent {
    // message fields
    pub time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub value: ::std::option::Option<Span_TimeEvent_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_TimeEvent {
    fn default() -> &'a Span_TimeEvent {
        <Span_TimeEvent as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Span_TimeEvent_oneof_value {
    annotation(Span_TimeEvent_Annotation),
    message_event(Span_TimeEvent_MessageEvent),
}

impl Span_TimeEvent {
    pub fn new() -> Span_TimeEvent {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp time = 1;


    pub fn get_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.devtools.cloudtrace.v2.Span.TimeEvent.Annotation annotation = 2;


    pub fn get_annotation(&self) -> &Span_TimeEvent_Annotation {
        match self.value {
            ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(ref v)) => v,
            _ => Span_TimeEvent_Annotation::default_instance(),
        }
    }
    pub fn clear_annotation(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_annotation(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_annotation(&mut self, v: Span_TimeEvent_Annotation) {
        self.value = ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_annotation(&mut self) -> &mut Span_TimeEvent_Annotation {
        if let ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(Span_TimeEvent_Annotation::new()));
        }
        match self.value {
            ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_annotation(&mut self) -> Span_TimeEvent_Annotation {
        if self.has_annotation() {
            match self.value.take() {
                ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(v)) => v,
                _ => panic!(),
            }
        } else {
            Span_TimeEvent_Annotation::new()
        }
    }

    // .google.devtools.cloudtrace.v2.Span.TimeEvent.MessageEvent message_event = 3;


    pub fn get_message_event(&self) -> &Span_TimeEvent_MessageEvent {
        match self.value {
            ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(ref v)) => v,
            _ => Span_TimeEvent_MessageEvent::default_instance(),
        }
    }
    pub fn clear_message_event(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_message_event(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message_event(&mut self, v: Span_TimeEvent_MessageEvent) {
        self.value = ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message_event(&mut self) -> &mut Span_TimeEvent_MessageEvent {
        if let ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(Span_TimeEvent_MessageEvent::new()));
        }
        match self.value {
            ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message_event(&mut self) -> Span_TimeEvent_MessageEvent {
        if self.has_message_event() {
            match self.value.take() {
                ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(v)) => v,
                _ => panic!(),
            }
        } else {
            Span_TimeEvent_MessageEvent::new()
        }
    }
}

impl ::protobuf::Message for Span_TimeEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.time {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Span_TimeEvent_oneof_value::annotation(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Span_TimeEvent_oneof_value::message_event(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Span_TimeEvent_oneof_value::annotation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Span_TimeEvent_oneof_value::message_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Span_TimeEvent_oneof_value::annotation(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Span_TimeEvent_oneof_value::message_event(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_TimeEvent {
        Span_TimeEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "time",
                    |m: &Span_TimeEvent| { &m.time },
                    |m: &mut Span_TimeEvent| { &mut m.time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Span_TimeEvent_Annotation>(
                    "annotation",
                    Span_TimeEvent::has_annotation,
                    Span_TimeEvent::get_annotation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Span_TimeEvent_MessageEvent>(
                    "message_event",
                    Span_TimeEvent::has_message_event,
                    Span_TimeEvent::get_message_event,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Span_TimeEvent>(
                    "Span_TimeEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Span_TimeEvent {
        static mut instance: ::protobuf::lazy::Lazy<Span_TimeEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Span_TimeEvent,
        };
        unsafe {
            instance.get(Span_TimeEvent::new)
        }
    }
}

impl ::protobuf::Clear for Span_TimeEvent {
    fn clear(&mut self) {
        self.time.clear();
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_TimeEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_TimeEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_TimeEvent_Annotation {
    // message fields
    pub description: ::protobuf::SingularPtrField<TruncatableString>,
    pub attributes: ::protobuf::SingularPtrField<Span_Attributes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_TimeEvent_Annotation {
    fn default() -> &'a Span_TimeEvent_Annotation {
        <Span_TimeEvent_Annotation as ::protobuf::Message>::default_instance()
    }
}

impl Span_TimeEvent_Annotation {
    pub fn new() -> Span_TimeEvent_Annotation {
        ::std::default::Default::default()
    }

    // .google.devtools.cloudtrace.v2.TruncatableString description = 1;


    pub fn get_description(&self) -> &TruncatableString {
        self.description.as_ref().unwrap_or_else(|| TruncatableString::default_instance())
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: TruncatableString) {
        self.description = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut TruncatableString {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> TruncatableString {
        self.description.take().unwrap_or_else(|| TruncatableString::new())
    }

    // .google.devtools.cloudtrace.v2.Span.Attributes attributes = 2;


    pub fn get_attributes(&self) -> &Span_Attributes {
        self.attributes.as_ref().unwrap_or_else(|| Span_Attributes::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: Span_Attributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut Span_Attributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> Span_Attributes {
        self.attributes.take().unwrap_or_else(|| Span_Attributes::new())
    }
}

impl ::protobuf::Message for Span_TimeEvent_Annotation {
    fn is_initialized(&self) -> bool {
        for v in &self.description {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.description)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.description.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.description.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_TimeEvent_Annotation {
        Span_TimeEvent_Annotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                    "description",
                    |m: &Span_TimeEvent_Annotation| { &m.description },
                    |m: &mut Span_TimeEvent_Annotation| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Attributes>>(
                    "attributes",
                    |m: &Span_TimeEvent_Annotation| { &m.attributes },
                    |m: &mut Span_TimeEvent_Annotation| { &mut m.attributes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Span_TimeEvent_Annotation>(
                    "Span_TimeEvent_Annotation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Span_TimeEvent_Annotation {
        static mut instance: ::protobuf::lazy::Lazy<Span_TimeEvent_Annotation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Span_TimeEvent_Annotation,
        };
        unsafe {
            instance.get(Span_TimeEvent_Annotation::new)
        }
    }
}

impl ::protobuf::Clear for Span_TimeEvent_Annotation {
    fn clear(&mut self) {
        self.description.clear();
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_TimeEvent_Annotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_TimeEvent_Annotation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_TimeEvent_MessageEvent {
    // message fields
    pub field_type: Span_TimeEvent_MessageEvent_Type,
    pub id: i64,
    pub uncompressed_size_bytes: i64,
    pub compressed_size_bytes: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_TimeEvent_MessageEvent {
    fn default() -> &'a Span_TimeEvent_MessageEvent {
        <Span_TimeEvent_MessageEvent as ::protobuf::Message>::default_instance()
    }
}

impl Span_TimeEvent_MessageEvent {
    pub fn new() -> Span_TimeEvent_MessageEvent {
        ::std::default::Default::default()
    }

    // .google.devtools.cloudtrace.v2.Span.TimeEvent.MessageEvent.Type type = 1;


    pub fn get_field_type(&self) -> Span_TimeEvent_MessageEvent_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Span_TimeEvent_MessageEvent_Type) {
        self.field_type = v;
    }

    // int64 id = 2;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    // int64 uncompressed_size_bytes = 3;


    pub fn get_uncompressed_size_bytes(&self) -> i64 {
        self.uncompressed_size_bytes
    }
    pub fn clear_uncompressed_size_bytes(&mut self) {
        self.uncompressed_size_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_uncompressed_size_bytes(&mut self, v: i64) {
        self.uncompressed_size_bytes = v;
    }

    // int64 compressed_size_bytes = 4;


    pub fn get_compressed_size_bytes(&self) -> i64 {
        self.compressed_size_bytes
    }
    pub fn clear_compressed_size_bytes(&mut self) {
        self.compressed_size_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_compressed_size_bytes(&mut self, v: i64) {
        self.compressed_size_bytes = v;
    }
}

impl ::protobuf::Message for Span_TimeEvent_MessageEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.uncompressed_size_bytes = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compressed_size_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.uncompressed_size_bytes != 0 {
            my_size += ::protobuf::rt::value_size(3, self.uncompressed_size_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.compressed_size_bytes != 0 {
            my_size += ::protobuf::rt::value_size(4, self.compressed_size_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED {
            os.write_enum(1, self.field_type.value())?;
        }
        if self.id != 0 {
            os.write_int64(2, self.id)?;
        }
        if self.uncompressed_size_bytes != 0 {
            os.write_int64(3, self.uncompressed_size_bytes)?;
        }
        if self.compressed_size_bytes != 0 {
            os.write_int64(4, self.compressed_size_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_TimeEvent_MessageEvent {
        Span_TimeEvent_MessageEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Span_TimeEvent_MessageEvent_Type>>(
                    "type",
                    |m: &Span_TimeEvent_MessageEvent| { &m.field_type },
                    |m: &mut Span_TimeEvent_MessageEvent| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &Span_TimeEvent_MessageEvent| { &m.id },
                    |m: &mut Span_TimeEvent_MessageEvent| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "uncompressed_size_bytes",
                    |m: &Span_TimeEvent_MessageEvent| { &m.uncompressed_size_bytes },
                    |m: &mut Span_TimeEvent_MessageEvent| { &mut m.uncompressed_size_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "compressed_size_bytes",
                    |m: &Span_TimeEvent_MessageEvent| { &m.compressed_size_bytes },
                    |m: &mut Span_TimeEvent_MessageEvent| { &mut m.compressed_size_bytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Span_TimeEvent_MessageEvent>(
                    "Span_TimeEvent_MessageEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Span_TimeEvent_MessageEvent {
        static mut instance: ::protobuf::lazy::Lazy<Span_TimeEvent_MessageEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Span_TimeEvent_MessageEvent,
        };
        unsafe {
            instance.get(Span_TimeEvent_MessageEvent::new)
        }
    }
}

impl ::protobuf::Clear for Span_TimeEvent_MessageEvent {
    fn clear(&mut self) {
        self.field_type = Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED;
        self.id = 0;
        self.uncompressed_size_bytes = 0;
        self.compressed_size_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_TimeEvent_MessageEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_TimeEvent_MessageEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Span_TimeEvent_MessageEvent_Type {
    TYPE_UNSPECIFIED = 0,
    SENT = 1,
    RECEIVED = 2,
}

impl ::protobuf::ProtobufEnum for Span_TimeEvent_MessageEvent_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Span_TimeEvent_MessageEvent_Type> {
        match value {
            0 => ::std::option::Option::Some(Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Span_TimeEvent_MessageEvent_Type::SENT),
            2 => ::std::option::Option::Some(Span_TimeEvent_MessageEvent_Type::RECEIVED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Span_TimeEvent_MessageEvent_Type] = &[
            Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED,
            Span_TimeEvent_MessageEvent_Type::SENT,
            Span_TimeEvent_MessageEvent_Type::RECEIVED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Span_TimeEvent_MessageEvent_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Span_TimeEvent_MessageEvent_Type {
}

impl ::std::default::Default for Span_TimeEvent_MessageEvent_Type {
    fn default() -> Self {
        Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_TimeEvent_MessageEvent_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_TimeEvents {
    // message fields
    pub time_event: ::protobuf::RepeatedField<Span_TimeEvent>,
    pub dropped_annotations_count: i32,
    pub dropped_message_events_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_TimeEvents {
    fn default() -> &'a Span_TimeEvents {
        <Span_TimeEvents as ::protobuf::Message>::default_instance()
    }
}

impl Span_TimeEvents {
    pub fn new() -> Span_TimeEvents {
        ::std::default::Default::default()
    }

    // repeated .google.devtools.cloudtrace.v2.Span.TimeEvent time_event = 1;


    pub fn get_time_event(&self) -> &[Span_TimeEvent] {
        &self.time_event
    }
    pub fn clear_time_event(&mut self) {
        self.time_event.clear();
    }

    // Param is passed by value, moved
    pub fn set_time_event(&mut self, v: ::protobuf::RepeatedField<Span_TimeEvent>) {
        self.time_event = v;
    }

    // Mutable pointer to the field.
    pub fn mut_time_event(&mut self) -> &mut ::protobuf::RepeatedField<Span_TimeEvent> {
        &mut self.time_event
    }

    // Take field
    pub fn take_time_event(&mut self) -> ::protobuf::RepeatedField<Span_TimeEvent> {
        ::std::mem::replace(&mut self.time_event, ::protobuf::RepeatedField::new())
    }

    // int32 dropped_annotations_count = 2;


    pub fn get_dropped_annotations_count(&self) -> i32 {
        self.dropped_annotations_count
    }
    pub fn clear_dropped_annotations_count(&mut self) {
        self.dropped_annotations_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_annotations_count(&mut self, v: i32) {
        self.dropped_annotations_count = v;
    }

    // int32 dropped_message_events_count = 3;


    pub fn get_dropped_message_events_count(&self) -> i32 {
        self.dropped_message_events_count
    }
    pub fn clear_dropped_message_events_count(&mut self) {
        self.dropped_message_events_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_message_events_count(&mut self, v: i32) {
        self.dropped_message_events_count = v;
    }
}

impl ::protobuf::Message for Span_TimeEvents {
    fn is_initialized(&self) -> bool {
        for v in &self.time_event {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.time_event)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dropped_annotations_count = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dropped_message_events_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.time_event {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.dropped_annotations_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.dropped_annotations_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dropped_message_events_count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dropped_message_events_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.time_event {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.dropped_annotations_count != 0 {
            os.write_int32(2, self.dropped_annotations_count)?;
        }
        if self.dropped_message_events_count != 0 {
            os.write_int32(3, self.dropped_message_events_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_TimeEvents {
        Span_TimeEvents::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_TimeEvent>>(
                    "time_event",
                    |m: &Span_TimeEvents| { &m.time_event },
                    |m: &mut Span_TimeEvents| { &mut m.time_event },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dropped_annotations_count",
                    |m: &Span_TimeEvents| { &m.dropped_annotations_count },
                    |m: &mut Span_TimeEvents| { &mut m.dropped_annotations_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dropped_message_events_count",
                    |m: &Span_TimeEvents| { &m.dropped_message_events_count },
                    |m: &mut Span_TimeEvents| { &mut m.dropped_message_events_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Span_TimeEvents>(
                    "Span_TimeEvents",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Span_TimeEvents {
        static mut instance: ::protobuf::lazy::Lazy<Span_TimeEvents> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Span_TimeEvents,
        };
        unsafe {
            instance.get(Span_TimeEvents::new)
        }
    }
}

impl ::protobuf::Clear for Span_TimeEvents {
    fn clear(&mut self) {
        self.time_event.clear();
        self.dropped_annotations_count = 0;
        self.dropped_message_events_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_TimeEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_TimeEvents {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_Link {
    // message fields
    pub trace_id: ::std::string::String,
    pub span_id: ::std::string::String,
    pub field_type: Span_Link_Type,
    pub attributes: ::protobuf::SingularPtrField<Span_Attributes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_Link {
    fn default() -> &'a Span_Link {
        <Span_Link as ::protobuf::Message>::default_instance()
    }
}

impl Span_Link {
    pub fn new() -> Span_Link {
        ::std::default::Default::default()
    }

    // string trace_id = 1;


    pub fn get_trace_id(&self) -> &str {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::string::String) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::string::String {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trace_id, ::std::string::String::new())
    }

    // string span_id = 2;


    pub fn get_span_id(&self) -> &str {
        &self.span_id
    }
    pub fn clear_span_id(&mut self) {
        self.span_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_span_id(&mut self, v: ::std::string::String) {
        self.span_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_span_id(&mut self) -> &mut ::std::string::String {
        &mut self.span_id
    }

    // Take field
    pub fn take_span_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.span_id, ::std::string::String::new())
    }

    // .google.devtools.cloudtrace.v2.Span.Link.Type type = 3;


    pub fn get_field_type(&self) -> Span_Link_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Span_Link_Type::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Span_Link_Type) {
        self.field_type = v;
    }

    // .google.devtools.cloudtrace.v2.Span.Attributes attributes = 4;


    pub fn get_attributes(&self) -> &Span_Attributes {
        self.attributes.as_ref().unwrap_or_else(|| Span_Attributes::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: Span_Attributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut Span_Attributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> Span_Attributes {
        self.attributes.take().unwrap_or_else(|| Span_Attributes::new())
    }
}

impl ::protobuf::Message for Span_Link {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trace_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.span_id)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.trace_id);
        }
        if !self.span_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.span_id);
        }
        if self.field_type != Span_Link_Type::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.trace_id.is_empty() {
            os.write_string(1, &self.trace_id)?;
        }
        if !self.span_id.is_empty() {
            os.write_string(2, &self.span_id)?;
        }
        if self.field_type != Span_Link_Type::TYPE_UNSPECIFIED {
            os.write_enum(3, self.field_type.value())?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_Link {
        Span_Link::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "trace_id",
                    |m: &Span_Link| { &m.trace_id },
                    |m: &mut Span_Link| { &mut m.trace_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "span_id",
                    |m: &Span_Link| { &m.span_id },
                    |m: &mut Span_Link| { &mut m.span_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Span_Link_Type>>(
                    "type",
                    |m: &Span_Link| { &m.field_type },
                    |m: &mut Span_Link| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Attributes>>(
                    "attributes",
                    |m: &Span_Link| { &m.attributes },
                    |m: &mut Span_Link| { &mut m.attributes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Span_Link>(
                    "Span_Link",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Span_Link {
        static mut instance: ::protobuf::lazy::Lazy<Span_Link> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Span_Link,
        };
        unsafe {
            instance.get(Span_Link::new)
        }
    }
}

impl ::protobuf::Clear for Span_Link {
    fn clear(&mut self) {
        self.trace_id.clear();
        self.span_id.clear();
        self.field_type = Span_Link_Type::TYPE_UNSPECIFIED;
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_Link {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_Link {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Span_Link_Type {
    TYPE_UNSPECIFIED = 0,
    CHILD_LINKED_SPAN = 1,
    PARENT_LINKED_SPAN = 2,
}

impl ::protobuf::ProtobufEnum for Span_Link_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Span_Link_Type> {
        match value {
            0 => ::std::option::Option::Some(Span_Link_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Span_Link_Type::CHILD_LINKED_SPAN),
            2 => ::std::option::Option::Some(Span_Link_Type::PARENT_LINKED_SPAN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Span_Link_Type] = &[
            Span_Link_Type::TYPE_UNSPECIFIED,
            Span_Link_Type::CHILD_LINKED_SPAN,
            Span_Link_Type::PARENT_LINKED_SPAN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Span_Link_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Span_Link_Type {
}

impl ::std::default::Default for Span_Link_Type {
    fn default() -> Self {
        Span_Link_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_Link_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_Links {
    // message fields
    pub link: ::protobuf::RepeatedField<Span_Link>,
    pub dropped_links_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_Links {
    fn default() -> &'a Span_Links {
        <Span_Links as ::protobuf::Message>::default_instance()
    }
}

impl Span_Links {
    pub fn new() -> Span_Links {
        ::std::default::Default::default()
    }

    // repeated .google.devtools.cloudtrace.v2.Span.Link link = 1;


    pub fn get_link(&self) -> &[Span_Link] {
        &self.link
    }
    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: ::protobuf::RepeatedField<Span_Link>) {
        self.link = v;
    }

    // Mutable pointer to the field.
    pub fn mut_link(&mut self) -> &mut ::protobuf::RepeatedField<Span_Link> {
        &mut self.link
    }

    // Take field
    pub fn take_link(&mut self) -> ::protobuf::RepeatedField<Span_Link> {
        ::std::mem::replace(&mut self.link, ::protobuf::RepeatedField::new())
    }

    // int32 dropped_links_count = 2;


    pub fn get_dropped_links_count(&self) -> i32 {
        self.dropped_links_count
    }
    pub fn clear_dropped_links_count(&mut self) {
        self.dropped_links_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_links_count(&mut self, v: i32) {
        self.dropped_links_count = v;
    }
}

impl ::protobuf::Message for Span_Links {
    fn is_initialized(&self) -> bool {
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.link)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dropped_links_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.link {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.dropped_links_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.dropped_links_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.link {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.dropped_links_count != 0 {
            os.write_int32(2, self.dropped_links_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_Links {
        Span_Links::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Link>>(
                    "link",
                    |m: &Span_Links| { &m.link },
                    |m: &mut Span_Links| { &mut m.link },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dropped_links_count",
                    |m: &Span_Links| { &m.dropped_links_count },
                    |m: &mut Span_Links| { &mut m.dropped_links_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Span_Links>(
                    "Span_Links",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Span_Links {
        static mut instance: ::protobuf::lazy::Lazy<Span_Links> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Span_Links,
        };
        unsafe {
            instance.get(Span_Links::new)
        }
    }
}

impl ::protobuf::Clear for Span_Links {
    fn clear(&mut self) {
        self.link.clear();
        self.dropped_links_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_Links {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_Links {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeValue {
    // message oneof groups
    pub value: ::std::option::Option<AttributeValue_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeValue {
    fn default() -> &'a AttributeValue {
        <AttributeValue as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AttributeValue_oneof_value {
    string_value(TruncatableString),
    int_value(i64),
    bool_value(bool),
}

impl AttributeValue {
    pub fn new() -> AttributeValue {
        ::std::default::Default::default()
    }

    // .google.devtools.cloudtrace.v2.TruncatableString string_value = 1;


    pub fn get_string_value(&self) -> &TruncatableString {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::string_value(ref v)) => v,
            _ => TruncatableString::default_instance(),
        }
    }
    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: TruncatableString) {
        self.value = ::std::option::Option::Some(AttributeValue_oneof_value::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut TruncatableString {
        if let ::std::option::Option::Some(AttributeValue_oneof_value::string_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(AttributeValue_oneof_value::string_value(TruncatableString::new()));
        }
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> TruncatableString {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(AttributeValue_oneof_value::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            TruncatableString::new()
        }
    }

    // int64 int_value = 2;


    pub fn get_int_value(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::int_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::int_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(AttributeValue_oneof_value::int_value(v))
    }

    // bool bool_value = 3;


    pub fn get_bool_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::bool_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_bool_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bool_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::bool_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(AttributeValue_oneof_value::bool_value(v))
    }
}

impl ::protobuf::Message for AttributeValue {
    fn is_initialized(&self) -> bool {
        if let Some(AttributeValue_oneof_value::string_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(AttributeValue_oneof_value::string_value(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(AttributeValue_oneof_value::int_value(is.read_int64()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(AttributeValue_oneof_value::bool_value(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &AttributeValue_oneof_value::string_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AttributeValue_oneof_value::int_value(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &AttributeValue_oneof_value::bool_value(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &AttributeValue_oneof_value::string_value(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AttributeValue_oneof_value::int_value(v) => {
                    os.write_int64(2, v)?;
                },
                &AttributeValue_oneof_value::bool_value(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeValue {
        AttributeValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TruncatableString>(
                    "string_value",
                    AttributeValue::has_string_value,
                    AttributeValue::get_string_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "int_value",
                    AttributeValue::has_int_value,
                    AttributeValue::get_int_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "bool_value",
                    AttributeValue::has_bool_value,
                    AttributeValue::get_bool_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeValue>(
                    "AttributeValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeValue {
        static mut instance: ::protobuf::lazy::Lazy<AttributeValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeValue,
        };
        unsafe {
            instance.get(AttributeValue::new)
        }
    }
}

impl ::protobuf::Clear for AttributeValue {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StackTrace {
    // message fields
    pub stack_frames: ::protobuf::SingularPtrField<StackTrace_StackFrames>,
    pub stack_trace_hash_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StackTrace {
    fn default() -> &'a StackTrace {
        <StackTrace as ::protobuf::Message>::default_instance()
    }
}

impl StackTrace {
    pub fn new() -> StackTrace {
        ::std::default::Default::default()
    }

    // .google.devtools.cloudtrace.v2.StackTrace.StackFrames stack_frames = 1;


    pub fn get_stack_frames(&self) -> &StackTrace_StackFrames {
        self.stack_frames.as_ref().unwrap_or_else(|| StackTrace_StackFrames::default_instance())
    }
    pub fn clear_stack_frames(&mut self) {
        self.stack_frames.clear();
    }

    pub fn has_stack_frames(&self) -> bool {
        self.stack_frames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_frames(&mut self, v: StackTrace_StackFrames) {
        self.stack_frames = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stack_frames(&mut self) -> &mut StackTrace_StackFrames {
        if self.stack_frames.is_none() {
            self.stack_frames.set_default();
        }
        self.stack_frames.as_mut().unwrap()
    }

    // Take field
    pub fn take_stack_frames(&mut self) -> StackTrace_StackFrames {
        self.stack_frames.take().unwrap_or_else(|| StackTrace_StackFrames::new())
    }

    // int64 stack_trace_hash_id = 2;


    pub fn get_stack_trace_hash_id(&self) -> i64 {
        self.stack_trace_hash_id
    }
    pub fn clear_stack_trace_hash_id(&mut self) {
        self.stack_trace_hash_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_stack_trace_hash_id(&mut self, v: i64) {
        self.stack_trace_hash_id = v;
    }
}

impl ::protobuf::Message for StackTrace {
    fn is_initialized(&self) -> bool {
        for v in &self.stack_frames {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stack_frames)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.stack_trace_hash_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stack_frames.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stack_trace_hash_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.stack_trace_hash_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stack_frames.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stack_trace_hash_id != 0 {
            os.write_int64(2, self.stack_trace_hash_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StackTrace {
        StackTrace::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StackTrace_StackFrames>>(
                    "stack_frames",
                    |m: &StackTrace| { &m.stack_frames },
                    |m: &mut StackTrace| { &mut m.stack_frames },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "stack_trace_hash_id",
                    |m: &StackTrace| { &m.stack_trace_hash_id },
                    |m: &mut StackTrace| { &mut m.stack_trace_hash_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StackTrace>(
                    "StackTrace",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StackTrace {
        static mut instance: ::protobuf::lazy::Lazy<StackTrace> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StackTrace,
        };
        unsafe {
            instance.get(StackTrace::new)
        }
    }
}

impl ::protobuf::Clear for StackTrace {
    fn clear(&mut self) {
        self.stack_frames.clear();
        self.stack_trace_hash_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StackTrace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StackTrace {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StackTrace_StackFrame {
    // message fields
    pub function_name: ::protobuf::SingularPtrField<TruncatableString>,
    pub original_function_name: ::protobuf::SingularPtrField<TruncatableString>,
    pub file_name: ::protobuf::SingularPtrField<TruncatableString>,
    pub line_number: i64,
    pub column_number: i64,
    pub load_module: ::protobuf::SingularPtrField<Module>,
    pub source_version: ::protobuf::SingularPtrField<TruncatableString>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StackTrace_StackFrame {
    fn default() -> &'a StackTrace_StackFrame {
        <StackTrace_StackFrame as ::protobuf::Message>::default_instance()
    }
}

impl StackTrace_StackFrame {
    pub fn new() -> StackTrace_StackFrame {
        ::std::default::Default::default()
    }

    // .google.devtools.cloudtrace.v2.TruncatableString function_name = 1;


    pub fn get_function_name(&self) -> &TruncatableString {
        self.function_name.as_ref().unwrap_or_else(|| TruncatableString::default_instance())
    }
    pub fn clear_function_name(&mut self) {
        self.function_name.clear();
    }

    pub fn has_function_name(&self) -> bool {
        self.function_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_name(&mut self, v: TruncatableString) {
        self.function_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_name(&mut self) -> &mut TruncatableString {
        if self.function_name.is_none() {
            self.function_name.set_default();
        }
        self.function_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_function_name(&mut self) -> TruncatableString {
        self.function_name.take().unwrap_or_else(|| TruncatableString::new())
    }

    // .google.devtools.cloudtrace.v2.TruncatableString original_function_name = 2;


    pub fn get_original_function_name(&self) -> &TruncatableString {
        self.original_function_name.as_ref().unwrap_or_else(|| TruncatableString::default_instance())
    }
    pub fn clear_original_function_name(&mut self) {
        self.original_function_name.clear();
    }

    pub fn has_original_function_name(&self) -> bool {
        self.original_function_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_function_name(&mut self, v: TruncatableString) {
        self.original_function_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_function_name(&mut self) -> &mut TruncatableString {
        if self.original_function_name.is_none() {
            self.original_function_name.set_default();
        }
        self.original_function_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_function_name(&mut self) -> TruncatableString {
        self.original_function_name.take().unwrap_or_else(|| TruncatableString::new())
    }

    // .google.devtools.cloudtrace.v2.TruncatableString file_name = 3;


    pub fn get_file_name(&self) -> &TruncatableString {
        self.file_name.as_ref().unwrap_or_else(|| TruncatableString::default_instance())
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: TruncatableString) {
        self.file_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut TruncatableString {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> TruncatableString {
        self.file_name.take().unwrap_or_else(|| TruncatableString::new())
    }

    // int64 line_number = 4;


    pub fn get_line_number(&self) -> i64 {
        self.line_number
    }
    pub fn clear_line_number(&mut self) {
        self.line_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_line_number(&mut self, v: i64) {
        self.line_number = v;
    }

    // int64 column_number = 5;


    pub fn get_column_number(&self) -> i64 {
        self.column_number
    }
    pub fn clear_column_number(&mut self) {
        self.column_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_column_number(&mut self, v: i64) {
        self.column_number = v;
    }

    // .google.devtools.cloudtrace.v2.Module load_module = 6;


    pub fn get_load_module(&self) -> &Module {
        self.load_module.as_ref().unwrap_or_else(|| Module::default_instance())
    }
    pub fn clear_load_module(&mut self) {
        self.load_module.clear();
    }

    pub fn has_load_module(&self) -> bool {
        self.load_module.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_module(&mut self, v: Module) {
        self.load_module = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_load_module(&mut self) -> &mut Module {
        if self.load_module.is_none() {
            self.load_module.set_default();
        }
        self.load_module.as_mut().unwrap()
    }

    // Take field
    pub fn take_load_module(&mut self) -> Module {
        self.load_module.take().unwrap_or_else(|| Module::new())
    }

    // .google.devtools.cloudtrace.v2.TruncatableString source_version = 7;


    pub fn get_source_version(&self) -> &TruncatableString {
        self.source_version.as_ref().unwrap_or_else(|| TruncatableString::default_instance())
    }
    pub fn clear_source_version(&mut self) {
        self.source_version.clear();
    }

    pub fn has_source_version(&self) -> bool {
        self.source_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_version(&mut self, v: TruncatableString) {
        self.source_version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_version(&mut self) -> &mut TruncatableString {
        if self.source_version.is_none() {
            self.source_version.set_default();
        }
        self.source_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_source_version(&mut self) -> TruncatableString {
        self.source_version.take().unwrap_or_else(|| TruncatableString::new())
    }
}

impl ::protobuf::Message for StackTrace_StackFrame {
    fn is_initialized(&self) -> bool {
        for v in &self.function_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.original_function_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.file_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.load_module {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source_version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.function_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.original_function_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.file_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.line_number = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.column_number = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.load_module)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.function_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.original_function_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.line_number != 0 {
            my_size += ::protobuf::rt::value_size(4, self.line_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.column_number != 0 {
            my_size += ::protobuf::rt::value_size(5, self.column_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.load_module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.source_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.function_name.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.original_function_name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.line_number != 0 {
            os.write_int64(4, self.line_number)?;
        }
        if self.column_number != 0 {
            os.write_int64(5, self.column_number)?;
        }
        if let Some(ref v) = self.load_module.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.source_version.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StackTrace_StackFrame {
        StackTrace_StackFrame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                    "function_name",
                    |m: &StackTrace_StackFrame| { &m.function_name },
                    |m: &mut StackTrace_StackFrame| { &mut m.function_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                    "original_function_name",
                    |m: &StackTrace_StackFrame| { &m.original_function_name },
                    |m: &mut StackTrace_StackFrame| { &mut m.original_function_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                    "file_name",
                    |m: &StackTrace_StackFrame| { &m.file_name },
                    |m: &mut StackTrace_StackFrame| { &mut m.file_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "line_number",
                    |m: &StackTrace_StackFrame| { &m.line_number },
                    |m: &mut StackTrace_StackFrame| { &mut m.line_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "column_number",
                    |m: &StackTrace_StackFrame| { &m.column_number },
                    |m: &mut StackTrace_StackFrame| { &mut m.column_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Module>>(
                    "load_module",
                    |m: &StackTrace_StackFrame| { &m.load_module },
                    |m: &mut StackTrace_StackFrame| { &mut m.load_module },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                    "source_version",
                    |m: &StackTrace_StackFrame| { &m.source_version },
                    |m: &mut StackTrace_StackFrame| { &mut m.source_version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StackTrace_StackFrame>(
                    "StackTrace_StackFrame",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StackTrace_StackFrame {
        static mut instance: ::protobuf::lazy::Lazy<StackTrace_StackFrame> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StackTrace_StackFrame,
        };
        unsafe {
            instance.get(StackTrace_StackFrame::new)
        }
    }
}

impl ::protobuf::Clear for StackTrace_StackFrame {
    fn clear(&mut self) {
        self.function_name.clear();
        self.original_function_name.clear();
        self.file_name.clear();
        self.line_number = 0;
        self.column_number = 0;
        self.load_module.clear();
        self.source_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StackTrace_StackFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StackTrace_StackFrame {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StackTrace_StackFrames {
    // message fields
    pub frame: ::protobuf::RepeatedField<StackTrace_StackFrame>,
    pub dropped_frames_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StackTrace_StackFrames {
    fn default() -> &'a StackTrace_StackFrames {
        <StackTrace_StackFrames as ::protobuf::Message>::default_instance()
    }
}

impl StackTrace_StackFrames {
    pub fn new() -> StackTrace_StackFrames {
        ::std::default::Default::default()
    }

    // repeated .google.devtools.cloudtrace.v2.StackTrace.StackFrame frame = 1;


    pub fn get_frame(&self) -> &[StackTrace_StackFrame] {
        &self.frame
    }
    pub fn clear_frame(&mut self) {
        self.frame.clear();
    }

    // Param is passed by value, moved
    pub fn set_frame(&mut self, v: ::protobuf::RepeatedField<StackTrace_StackFrame>) {
        self.frame = v;
    }

    // Mutable pointer to the field.
    pub fn mut_frame(&mut self) -> &mut ::protobuf::RepeatedField<StackTrace_StackFrame> {
        &mut self.frame
    }

    // Take field
    pub fn take_frame(&mut self) -> ::protobuf::RepeatedField<StackTrace_StackFrame> {
        ::std::mem::replace(&mut self.frame, ::protobuf::RepeatedField::new())
    }

    // int32 dropped_frames_count = 2;


    pub fn get_dropped_frames_count(&self) -> i32 {
        self.dropped_frames_count
    }
    pub fn clear_dropped_frames_count(&mut self) {
        self.dropped_frames_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_frames_count(&mut self, v: i32) {
        self.dropped_frames_count = v;
    }
}

impl ::protobuf::Message for StackTrace_StackFrames {
    fn is_initialized(&self) -> bool {
        for v in &self.frame {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.frame)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dropped_frames_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.frame {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.dropped_frames_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.dropped_frames_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.frame {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.dropped_frames_count != 0 {
            os.write_int32(2, self.dropped_frames_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StackTrace_StackFrames {
        StackTrace_StackFrames::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StackTrace_StackFrame>>(
                    "frame",
                    |m: &StackTrace_StackFrames| { &m.frame },
                    |m: &mut StackTrace_StackFrames| { &mut m.frame },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dropped_frames_count",
                    |m: &StackTrace_StackFrames| { &m.dropped_frames_count },
                    |m: &mut StackTrace_StackFrames| { &mut m.dropped_frames_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StackTrace_StackFrames>(
                    "StackTrace_StackFrames",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StackTrace_StackFrames {
        static mut instance: ::protobuf::lazy::Lazy<StackTrace_StackFrames> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StackTrace_StackFrames,
        };
        unsafe {
            instance.get(StackTrace_StackFrames::new)
        }
    }
}

impl ::protobuf::Clear for StackTrace_StackFrames {
    fn clear(&mut self) {
        self.frame.clear();
        self.dropped_frames_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StackTrace_StackFrames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StackTrace_StackFrames {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Module {
    // message fields
    pub module: ::protobuf::SingularPtrField<TruncatableString>,
    pub build_id: ::protobuf::SingularPtrField<TruncatableString>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Module {
    fn default() -> &'a Module {
        <Module as ::protobuf::Message>::default_instance()
    }
}

impl Module {
    pub fn new() -> Module {
        ::std::default::Default::default()
    }

    // .google.devtools.cloudtrace.v2.TruncatableString module = 1;


    pub fn get_module(&self) -> &TruncatableString {
        self.module.as_ref().unwrap_or_else(|| TruncatableString::default_instance())
    }
    pub fn clear_module(&mut self) {
        self.module.clear();
    }

    pub fn has_module(&self) -> bool {
        self.module.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module(&mut self, v: TruncatableString) {
        self.module = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module(&mut self) -> &mut TruncatableString {
        if self.module.is_none() {
            self.module.set_default();
        }
        self.module.as_mut().unwrap()
    }

    // Take field
    pub fn take_module(&mut self) -> TruncatableString {
        self.module.take().unwrap_or_else(|| TruncatableString::new())
    }

    // .google.devtools.cloudtrace.v2.TruncatableString build_id = 2;


    pub fn get_build_id(&self) -> &TruncatableString {
        self.build_id.as_ref().unwrap_or_else(|| TruncatableString::default_instance())
    }
    pub fn clear_build_id(&mut self) {
        self.build_id.clear();
    }

    pub fn has_build_id(&self) -> bool {
        self.build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_id(&mut self, v: TruncatableString) {
        self.build_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build_id(&mut self) -> &mut TruncatableString {
        if self.build_id.is_none() {
            self.build_id.set_default();
        }
        self.build_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_build_id(&mut self) -> TruncatableString {
        self.build_id.take().unwrap_or_else(|| TruncatableString::new())
    }
}

impl ::protobuf::Message for Module {
    fn is_initialized(&self) -> bool {
        for v in &self.module {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.build_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.module)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.build_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.build_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.module.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.build_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Module {
        Module::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                    "module",
                    |m: &Module| { &m.module },
                    |m: &mut Module| { &mut m.module },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                    "build_id",
                    |m: &Module| { &m.build_id },
                    |m: &mut Module| { &mut m.build_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Module>(
                    "Module",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Module {
        static mut instance: ::protobuf::lazy::Lazy<Module> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Module,
        };
        unsafe {
            instance.get(Module::new)
        }
    }
}

impl ::protobuf::Clear for Module {
    fn clear(&mut self) {
        self.module.clear();
        self.build_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Module {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Module {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TruncatableString {
    // message fields
    pub value: ::std::string::String,
    pub truncated_byte_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TruncatableString {
    fn default() -> &'a TruncatableString {
        <TruncatableString as ::protobuf::Message>::default_instance()
    }
}

impl TruncatableString {
    pub fn new() -> TruncatableString {
        ::std::default::Default::default()
    }

    // string value = 1;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // int32 truncated_byte_count = 2;


    pub fn get_truncated_byte_count(&self) -> i32 {
        self.truncated_byte_count
    }
    pub fn clear_truncated_byte_count(&mut self) {
        self.truncated_byte_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_truncated_byte_count(&mut self, v: i32) {
        self.truncated_byte_count = v;
    }
}

impl ::protobuf::Message for TruncatableString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.truncated_byte_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if self.truncated_byte_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.truncated_byte_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if self.truncated_byte_count != 0 {
            os.write_int32(2, self.truncated_byte_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TruncatableString {
        TruncatableString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &TruncatableString| { &m.value },
                    |m: &mut TruncatableString| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "truncated_byte_count",
                    |m: &TruncatableString| { &m.truncated_byte_count },
                    |m: &mut TruncatableString| { &mut m.truncated_byte_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TruncatableString>(
                    "TruncatableString",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TruncatableString {
        static mut instance: ::protobuf::lazy::Lazy<TruncatableString> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TruncatableString,
        };
        unsafe {
            instance.get(TruncatableString::new)
        }
    }
}

impl ::protobuf::Clear for TruncatableString {
    fn clear(&mut self) {
        self.value.clear();
        self.truncated_byte_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TruncatableString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TruncatableString {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)google/devtools/cloudtrace/v2/trace.proto\x12\x1dgoogle.devtools.clou\
    dtrace.v2\x1a\x1cgoogle/api/annotations.proto\x1a\x1fgoogle/api/field_be\
    havior.proto\x1a\x19google/api/resource.proto\x1a\x1fgoogle/protobuf/tim\
    estamp.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a\x17google/rpc/sta\
    tus.proto\"\xf7\x13\n\x04Span\x12\x17\n\x04name\x18\x01\x20\x01(\tR\x04n\
    ameB\x03\xe0A\x02\x12\x1c\n\x07span_id\x18\x02\x20\x01(\tR\x06spanIdB\
    \x03\xe0A\x02\x12$\n\x0eparent_span_id\x18\x03\x20\x01(\tR\x0cparentSpan\
    Id\x12X\n\x0cdisplay_name\x18\x04\x20\x01(\x0b20.google.devtools.cloudtr\
    ace.v2.TruncatableStringR\x0bdisplayNameB\x03\xe0A\x02\x12>\n\nstart_tim\
    e\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tstartTimeB\x03\
    \xe0A\x02\x12:\n\x08end_time\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.T\
    imestampR\x07endTimeB\x03\xe0A\x02\x12N\n\nattributes\x18\x07\x20\x01(\
    \x0b2..google.devtools.cloudtrace.v2.Span.AttributesR\nattributes\x12J\n\
    \x0bstack_trace\x18\x08\x20\x01(\x0b2).google.devtools.cloudtrace.v2.Sta\
    ckTraceR\nstackTrace\x12O\n\x0btime_events\x18\t\x20\x01(\x0b2..google.d\
    evtools.cloudtrace.v2.Span.TimeEventsR\ntimeEvents\x12?\n\x05links\x18\n\
    \x20\x01(\x0b2).google.devtools.cloudtrace.v2.Span.LinksR\x05links\x12/\
    \n\x06status\x18\x0b\x20\x01(\x0b2\x12.google.rpc.StatusR\x06statusB\x03\
    \xe0A\x01\x12]\n\x1bsame_process_as_parent_span\x18\x0c\x20\x01(\x0b2\
    \x1a.google.protobuf.BoolValueR\x17sameProcessAsParentSpanB\x03\xe0A\x01\
    \x12J\n\x10child_span_count\x18\r\x20\x01(\x0b2\x1b.google.protobuf.Int3\
    2ValueR\x0echildSpanCountB\x03\xe0A\x01\x1a\x9d\x02\n\nAttributes\x12e\n\
    \rattribute_map\x18\x01\x20\x03(\x0b2@.google.devtools.cloudtrace.v2.Spa\
    n.Attributes.AttributeMapEntryR\x0cattributeMap\x128\n\x18dropped_attrib\
    utes_count\x18\x02\x20\x01(\x05R\x16droppedAttributesCount\x1an\n\x11Att\
    ributeMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12C\n\x05val\
    ue\x18\x02\x20\x01(\x0b2-.google.devtools.cloudtrace.v2.AttributeValueR\
    \x05value:\x028\x01\x1a\xce\x05\n\tTimeEvent\x12.\n\x04time\x18\x01\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\x04time\x12Z\n\nannotation\x18\
    \x02\x20\x01(\x0b28.google.devtools.cloudtrace.v2.Span.TimeEvent.Annotat\
    ionH\0R\nannotation\x12a\n\rmessage_event\x18\x03\x20\x01(\x0b2:.google.\
    devtools.cloudtrace.v2.Span.TimeEvent.MessageEventH\0R\x0cmessageEvent\
    \x1a\xb0\x01\n\nAnnotation\x12R\n\x0bdescription\x18\x01\x20\x01(\x0b20.\
    google.devtools.cloudtrace.v2.TruncatableStringR\x0bdescription\x12N\n\n\
    attributes\x18\x02\x20\x01(\x0b2..google.devtools.cloudtrace.v2.Span.Att\
    ributesR\nattributes\x1a\x95\x02\n\x0cMessageEvent\x12S\n\x04type\x18\
    \x01\x20\x01(\x0e2?.google.devtools.cloudtrace.v2.Span.TimeEvent.Message\
    Event.TypeR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\x03R\x02id\x126\n\
    \x17uncompressed_size_bytes\x18\x03\x20\x01(\x03R\x15uncompressedSizeByt\
    es\x122\n\x15compressed_size_bytes\x18\x04\x20\x01(\x03R\x13compressedSi\
    zeBytes\"4\n\x04Type\x12\x14\n\x10TYPE_UNSPECIFIED\x10\0\x12\x08\n\x04SE\
    NT\x10\x01\x12\x0c\n\x08RECEIVED\x10\x02B\x07\n\x05value\x1a\xd7\x01\n\n\
    TimeEvents\x12L\n\ntime_event\x18\x01\x20\x03(\x0b2-.google.devtools.clo\
    udtrace.v2.Span.TimeEventR\ttimeEvent\x12:\n\x19dropped_annotations_coun\
    t\x18\x02\x20\x01(\x05R\x17droppedAnnotationsCount\x12?\n\x1cdropped_mes\
    sage_events_count\x18\x03\x20\x01(\x05R\x19droppedMessageEventsCount\x1a\
    \x9a\x02\n\x04Link\x12\x19\n\x08trace_id\x18\x01\x20\x01(\tR\x07traceId\
    \x12\x17\n\x07span_id\x18\x02\x20\x01(\tR\x06spanId\x12A\n\x04type\x18\
    \x03\x20\x01(\x0e2-.google.devtools.cloudtrace.v2.Span.Link.TypeR\x04typ\
    e\x12N\n\nattributes\x18\x04\x20\x01(\x0b2..google.devtools.cloudtrace.v\
    2.Span.AttributesR\nattributes\"K\n\x04Type\x12\x14\n\x10TYPE_UNSPECIFIE\
    D\x10\0\x12\x15\n\x11CHILD_LINKED_SPAN\x10\x01\x12\x16\n\x12PARENT_LINKE\
    D_SPAN\x10\x02\x1au\n\x05Links\x12<\n\x04link\x18\x01\x20\x03(\x0b2(.goo\
    gle.devtools.cloudtrace.v2.Span.LinkR\x04link\x12.\n\x13dropped_links_co\
    unt\x18\x02\x20\x01(\x05R\x11droppedLinksCount:S\xeaAP\n\x1ecloudtrace.g\
    oogleapis.com/Span\x12.projects/{project}/traces/{trace}/spans/{span}\"\
    \xb0\x01\n\x0eAttributeValue\x12U\n\x0cstring_value\x18\x01\x20\x01(\x0b\
    20.google.devtools.cloudtrace.v2.TruncatableStringH\0R\x0bstringValue\
    \x12\x1d\n\tint_value\x18\x02\x20\x01(\x03H\0R\x08intValue\x12\x1f\n\nbo\
    ol_value\x18\x03\x20\x01(\x08H\0R\tboolValueB\x07\n\x05value\"\xa7\x06\n\
    \nStackTrace\x12X\n\x0cstack_frames\x18\x01\x20\x01(\x0b25.google.devtoo\
    ls.cloudtrace.v2.StackTrace.StackFramesR\x0bstackFrames\x12-\n\x13stack_\
    trace_hash_id\x18\x02\x20\x01(\x03R\x10stackTraceHashId\x1a\x81\x04\n\nS\
    tackFrame\x12U\n\rfunction_name\x18\x01\x20\x01(\x0b20.google.devtools.c\
    loudtrace.v2.TruncatableStringR\x0cfunctionName\x12f\n\x16original_funct\
    ion_name\x18\x02\x20\x01(\x0b20.google.devtools.cloudtrace.v2.Truncatabl\
    eStringR\x14originalFunctionName\x12M\n\tfile_name\x18\x03\x20\x01(\x0b2\
    0.google.devtools.cloudtrace.v2.TruncatableStringR\x08fileName\x12\x1f\n\
    \x0bline_number\x18\x04\x20\x01(\x03R\nlineNumber\x12#\n\rcolumn_number\
    \x18\x05\x20\x01(\x03R\x0ccolumnNumber\x12F\n\x0bload_module\x18\x06\x20\
    \x01(\x0b2%.google.devtools.cloudtrace.v2.ModuleR\nloadModule\x12W\n\x0e\
    source_version\x18\x07\x20\x01(\x0b20.google.devtools.cloudtrace.v2.Trun\
    catableStringR\rsourceVersion\x1a\x8b\x01\n\x0bStackFrames\x12J\n\x05fra\
    me\x18\x01\x20\x03(\x0b24.google.devtools.cloudtrace.v2.StackTrace.Stack\
    FrameR\x05frame\x120\n\x14dropped_frames_count\x18\x02\x20\x01(\x05R\x12\
    droppedFramesCount\"\x9f\x01\n\x06Module\x12H\n\x06module\x18\x01\x20\
    \x01(\x0b20.google.devtools.cloudtrace.v2.TruncatableStringR\x06module\
    \x12K\n\x08build_id\x18\x02\x20\x01(\x0b20.google.devtools.cloudtrace.v2\
    .TruncatableStringR\x07buildId\"[\n\x11TruncatableString\x12\x14\n\x05va\
    lue\x18\x01\x20\x01(\tR\x05value\x120\n\x14truncated_byte_count\x18\x02\
    \x20\x01(\x05R\x12truncatedByteCountB\xaa\x01\n!com.google.devtools.clou\
    dtrace.v2B\nTraceProtoP\x01ZGgoogle.golang.org/genproto/googleapis/devto\
    ols/cloudtrace/v2;cloudtrace\xaa\x02\x15Google.Cloud.Trace.V2\xca\x02\
    \x15Google\\Cloud\\Trace\\V2b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
